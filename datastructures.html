<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Structures</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<nav class="navbar">
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="algorithms.html">Algorithms</a></li>
        <li><a href="pseudocode.html">Pseudocode</a></li>
        <li><a href="datastructures.html" class="active">Data Structures</a></li>
    </ul>
</nav>

<div class="section">
    <h2>Data Structures</h2>

    <h3>1. Array</h3>
    <pre>

    our_bday = [7, 11, 13, 19, 22, 29, 8, 9, 28, 10]
    our_bday.append(1)
    print(our_bday[9])
    our_bday.remove(11)
    print(len(our_bday))

    OUTPUT:
    10
    10
    </pre>

    <h3>2. Stack – Infix, Postfix, Prefix</h3>
    <h4>Infix to Postfix</h4>
    <pre>

    def infix_to_postfix(expression):
        stack = []
        postfix = []
        
        precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0, ')': 0}
        
        for token in expression.split():
            if token.isalnum():  
                postfix.append(token)
            elif token == '(':  
                stack.append(token)
            elif token == ')':  
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()  
            else:  
                while stack and precedence.get(stack[-1], 0) >= precedence[token]:
                    postfix.append(stack.pop())
                stack.append(token)
        
        while stack:
            postfix.append(stack.pop())
        
        return ' '.join(postfix)


    expr = "A + B - C * D / E"
    postfix_expr = infix_to_postfix(expr)
    print(postfix_expr)

    OUTPUT:
    A B + C D * E / -

    </pre>

    <h4>Postfix Evaluation</h4>
    <pre>

    def eval_postfix(expression):
        stack = []

        for token in expression.split():
            if token.isalnum():  
                stack.append(token)
            else:  # Operator
                b = stack.pop()
                a = stack.pop()
                stack.append(f"{a} {token} {b}")  
        return stack[0]

    postfix_expr = "A B + C E * D / -"
    result = eval_postfix(postfix_expr)
    print(result)

    OUTPUT:
    A + B - C * E / D

    </pre>

    <h4>Prefix Evaluation</h4>
    <pre>

    def eval_prefix(expression):
        stack = []
        tokens = expression.split()[::-1]  

        for token in tokens:
            if token.isalnum():  
                stack.append(token)
            else:  
                a = stack.pop()
                b = stack.pop()
                stack.append(f"{a} {token} {b}")  
        return stack[0]

    prefix_expr = "- + A B / * C E D"
    result = eval_prefix(prefix_expr)
    print(result)

    OUTPUT:
    A + B - C * E / D

    </pre>

    <h3>3. Queue</h3>
    <pre>

    from collections import deque

    call = deque()

    def join_call(name):
        call.append(name)
        print(f"{name} is on the call.")

    def leave_call():
        if call:
            left = call.popleft()
            print(f"{left} has left the call.")
        else:
            print("No one is on the call!")

    join_call("Rhayven")
    join_call("Dale")
    join_call("Jerven")

    print("\nCurrent participants:", list(call))

    leave_call()
    leave_call()

    print("\nCurrent participants:", list(call))

    OUTPUT:
    Rhayven is on the call.
    Dale is on the call.
    Jerven is on the call.

    Current participants: ['Rhayven', 'Dale', 'Jerven']
    Rhayven has left the call.
    Dale has left the call.

    Current participants: ['Jerven']

    </pre>

    <h3>4. Trees – Inorder, Preorder, Postorder</h3>
    <h4>Preorder</h4>
    <pre>

    class Node:
        def __init__(self, data):
            self.data = data
            self.left = None
            self.right = None

    root = Node('A')
    root.left = Node('B')
    root.right = Node('C')
    root.left.left = Node('D')
    root.left.right = Node('E')
    root.right.right = Node('F')

    def preorder(node):
        if node:
            print(node.data, end=' ')  
            preorder(node.left)       
            preorder(node.right)       

    print("Preorder Traversal:")
    preorder(root)  

    OUTPUT:
    Preorder Traversal:
    A B D E C F

    </pre>

    <h4>Inorder</h4>
    <pre>
        
    class Node:
        def __init__(self, data):
            self.data = data
            self.left = None
            self.right = None


    root = Node('A')
    root.left = Node('B')
    root.right = Node('C')
    root.left.left = Node('D')
    root.left.right = Node('E')
    root.right.right = Node('F')


    def inorder(node):
        if node:
            inorder(node.left)  
            print(node.data, end=' ')
            inorder(node.right)  

    print("Inorder Traversal:")
    inorder(root)  

    OUTPUT: 
    Inorder Traversal:
    D B E A C F

    </pre>

    <h4>Postorder</h4>
    <pre>
        
    class Node:
        def __init__(self, data):
            self.data = data
            self.left = None
            self.right = None

    root = Node('A')
    root.left = Node('B')
    root.right = Node('C')
    root.left.left = Node('D')
    root.left.right = Node('E')
    root.right.right = Node('F')

    def postorder(node):
        if node:
            postorder(node.left)   
            postorder(node.right)  
            print(node.data, end=' ')  

    print("Postorder Traversal:")
    postorder(root)  

    OUTPUT:
    Postorder Traversal:
    D E B F C A

    </pre>
    


</div>

<footer>
    <div class="req">For CC104 Final Requirement</div>
</footer>

</body>
</html>
